---
title: java泛型（一）
date: 2022-03-18 22:30:00
permalink: /pages/20220318223000
categories: 
  - Java进阶
  - Java语法
tags: 
  - Java
author: 
  name: ALing
  link: https://github.com/CYL-ALing
---


## 泛型是什么？
&emsp;&emsp;俗话说得好，泛型用的好，下班下的早。
泛型 ，顾名思义就是 广泛的数据类型，也就是说什么数据类型都可以。

一般来说，我们见到的泛型就是这个样子，用 T 表示。

&emsp;&emsp;如下所示，在类名后方申明泛型 T，接着就可以在成员变量、方法中使用泛型了。
下面是我们经常看到的泛型类。
```java
public class User<T> {
	
	private T name;
}
```
&emsp;&emsp;对于这个name变量，我们可以放入不同数据类型的值，比如String,Int,Double,Float,Char等等数据类型
下面测试类创建了三个User类对象，第一个对象的name属性放入了String字符串，第二个放入了int整数，第三个放入了Double浮点数
```java
//泛型测试方法
public static void main(String[] args) {
	User user1 = new User();
	user1.setName("zwz");
	System.out.println(user1.getName() instanceof String);
	
	User user2 = new User();
	user2.setName(123456);
	System.out.println(user2.getName() instanceof Integer);
	
	User user3 = new User();
	user3.setName(123.456);
	System.out.println(user3.getName() instanceof Double);
}
```
你会发现，不管放入什么类型数据，都可以正常运行
## 为什么我们需要泛型？
通过以下两段代码说明为什么我们需要泛型
```java
public int addInt(int x,int y) {
  return x+y;
}
public float addFloat(float x,float y) {
  return x+y;
}
```
实际开发中，经常有数值类型求和的需求，例如int类型的求和，float类型的求和，long类型的求和，如果还需要double类型的求和呢，怎么办？难道我们每一个类型写一个方法？（也不是不行，但从代码复用性来讲没必要），完全可以使用泛型来写，代码如下：
```java
public <T extends Number> double add(T t1,T t2){
  return t1.doubleValue() + t2.doubleValue()
}
```
无论传入的是int,float,double,long，都能相加。接着看下一段：
```java
package cn.enjoyedu.generic.needgeneric;

import java.util.ArrayList;
import java.util.List;

public class NonGeneric2 {
    public static void main(String[] args) {
        List<String> list = new ArrayList();
        list.add("mark");
        list.add("OK");
        //list.add(100);

        for (int i = 0; i < list.size(); i++) {
            String name = list.get(i); // 1
            System.out.println("name:" + name);
        }
    }
}
```
&emsp;&emsp;定义了一个List类型的集合，先向其加入两个字符串类型的值，随后加入一个Integer类型的值。这完全是允许的，因为此时list默认的类型是Object类型。编译阶段是正常的，但是运行的时候会出现"java.lang.ClassCastException"异常。因此，导致此类错误在编码过程中不易被发现。
&emsp;&emsp;在如上的编码过程中，我们发现主要存在两个问题：
1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object类型，但其运行时类型仍然为其本身。
2.因此，从1处取出集合元素时需要人为的强制类型转换到具体的目标类型，且很容易出现"java.lang.ClassCastException"异常。
所以泛型的好处是：
+ 使用与多种数据类型执行相同的代码
- 泛型中的类型在使用时指定，不需要强制类型转换

## 泛型类和泛型接口
泛型类：
```java
public class NormalGeneric<T> {
    private T data;

    public NormalGeneric() {
    }

    public NormalGeneric(K data) {
        this.data = data;
    }
}
```
```java
public class NormalGeneric2<T,K> {
    private T data;
    private K result;

    public NormalGeneric2() {
    }
}
```
泛型接口（与泛型类的定义基本相同）：
```java
public interface Genertor<T> {
    public T next();
}
```
而实现泛型接口的类，有两种实现方法
1.未传入泛型实参时：
```java
public class ImplGenertor<T> implements Genertor<T> {
    @Override
    public T next() {
        return null;
    }
}

//在new出实例时，需要指定具体类型
public static void main(String[] args) {
  ImplGenertor<String> implGenerator = new ImplGenertor();
}
```
2.传入泛型实参：
```java
public class ImplGenertor2 implements Genertor<String> {
    @Override
    public String next() {
        return "ok";
    }
}

//在new 出类的实例时，和普通类没区别
```
## 泛型方法
&emsp;&emsp;泛型方法，是在调用的时候指明泛型的具体类型，泛型方法可以在任何地方任何场景中使用，包括普通类和泛型类。注意泛型类中定义的普通方法和泛型方法的区别
普通方法：
```java
 //这个类是个泛型类，在上面已经介绍过
    public class Generic<T>{
        private T key;

        public Generic(T key) {
            this.key = key;
        }

        //虽然在方法中使用了泛型，但是这并不是一个泛型方法。
        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
        //所以在这个方法中才可以继续使用 T 这个泛型。
        public T getKey(){
            return key;
        }

        /**
         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"
         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
         */
//        public E setKey(E key){
//            this.key = key;
//        }
    }
```
泛型方法:
```java
    /**
     * 这才是一个真正的泛型方法。
     * 首先在public与返回值之间的<T>必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
     * 这个T可以出现在这个泛型方法的任意位置.
     * 泛型的数量也可以为任意多个
     *    如：public <T,K> K showKeyName(Generic<T> container){
     *        ...
     *        }
     */
     public <T> T showKeyName(Generic<T> container){
       System.out.println("container key:" container.getKey());
       //例子只是为了说明泛型方法的特性
       T test = container.getKey();
        return test;
    }
```
## 限定类型变量
有时候，我们需要对类型变量加以约束，比如计算两个变量的最小，最大值。
```java
    public static <T> T min(T a,T b) {
        if(a.compareTO(b) > 0) return a; else return b;
    }

```
&emsp;&emsp;请问，如何确保传入的两个变量一定有compareTo方法？解决这个问题的方案就是将T限制为实现了接口的Comparable的类
```java
    public static <T extends Comparable> T min(T a,T b){
        if(a.compareTo(b) > 0) return b; else return a;
    }
```
&emsp;&emsp;T extends Comparable中，T 表示应该绑定类型的子类型，Comparable表示绑定类型，子类型和绑定类型可以是类也可以是接口。如果这个时候，我们试图传入一个没有实现接口Comparable的类的实例，将会发生编译错误。
![限定类型变量](https://github.com/CYL-ALing/BlogImg/blob/main/%E6%B3%9B%E5%9E%8B%E9%99%90%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F.png?raw=true)

&emsp;&emsp;同时extends左右都允许有多个，如 T,V extends Comparable $ Serializable的第一个。
这种类的限定既可以用再泛型方法上也可也以用在泛型类上。

## 泛型中的约束和局限性
现在我们有泛型类
```java
    public class Restrict<T> {}
```
**不能用基本类型实例化类型参数**
```java
    //Restrict<double> 这种是不允许的   要用Double  包装类型
    Restrict<Double> restrict = new Restrict<>();
```

**运行时类型查询只适用于原始类型**
```java
    //if(restrict instance Restrict<Doublt>){}  这种不允许 
    //if(restrict instance Restrict<T>){}  这种不允许 
    Restrict<String> retrict = new Restrict<>();
    System,out.println(restrict.getClass() == restrictString.getClass());
    System,out.println(restrict.getClass().getName());
```
**泛型类的静态上下文中类型变量失效**
```java
    //静态域或者方法里不能引用类型变量
    //private static T instance;
    //静态方法  本身是泛型方法就行
    //private static <T> T getInstance(){}
```
&emsp;&emsp;不能在静态域或静态方法中引用类型变量。因为泛型是要在对象创建的时候才知道是什么类型，而对象创建的代码执行先后顺序是static的部分已经执行了，如果你在静态部分引用了泛型，那么毫无疑问虚拟机根本不知道是什么东西，因为这个时候类还没有初始化。
**不能创建参数化类型的数组**
```java
    Restrict<Double> restrictArray; //可以
    //Restrict<Double> restrictArray2 = new Restrict<Double>[10];不允许
```
**不能实例化类型变量**
```java
//    public Restrict() {
//        this.data = new T();
//    }
```
**不能捕获泛型类的实例**
```java
    //泛型类不能extends Exception/Throwable
    //private class Problem<T> extends Exception{}
    //不能捕获泛型类对象
//    public <T extends Throwable> void doWork(T t){
//       try{
//
//       }catch(T e) {
//            //do sth...
//        }
//    }
```
但是可以这样：
```java
    public <T extends Throwable> void doWork(T t) throws T{
        try{

        }catch(Throwable e){
            throw t;
        }
    }
```
## 泛型类的继承规则
现在我们有一个类和子类和有一个泛型类
```java
    public class Employee{}

    public class Worker extends Employee {

    }

    //泛型类
    public class Pair<T>{}
```

```java
    //请问Pair<Employee> 和 Pair<Worker>是继承关系吗？
    //答案：不是，他们之间没有什么关系
    Employee employee = new Worker();
    //Pair<Employee> employeePair2 = new Pair<Worker>();  //会报错

    /*泛型类可以继承或者扩展其它类，比如List h和 ArrayList*/
    private static class ExtendPair<T> extends Pair<T>{

    }

    //但是泛型类可以继承或扩展其它类型，比如List h和 ArrayList
     Pair<Employee> pair = new ExtendPair<>();
```
## 通配符类型
&emsp;&emsp;正是因为前面所述的，```Pair<Employee> ```和 ```Pair<Worker>```没有任何关系，如果我们有一个泛型和一个方法
```java
    public static void print(GenericType<Fruit> p){}

    public class GenericType<T>{
       
    }

    public class Fruit{}

    public class Orange extends Fruit {}

    public class Apple extends Fruit{}

    public class HoneFuShi extends Apple{}

    //则会产生这种情况
    public static void use(){
        GenericType<Fruit> a = new GenericType<>();
        print(a);
        //GenericType<Orange> b = new GenericType<>();
        //print(b); //不允许
    }
```
为了解决这个问题，于是提出了一个通配符类型 ？
有两种使用方式：
**？ extends X** 表示类型的上界，类型参数是X的子类，
**? super X**表示类型的下界，类型参数是X的超类。
这两种方式 从名字上来看，特别是super，很有迷惑性，下面我们来仔细辨析这两种方法。
## ？extends X
表示传递给方法的参数，必须是X的子类（包括X 本身）
```java
    public static void print2(GenericType<? extends Fruit> p){
        System.out.println(p.getData().getColor());
    }
    public static void use2(){
        GenericType<Fruit> a = new GenericType<>();
        print2(a);
        GenericType<Orange> b = new GenericType<>();
        print2(b);
        GenericType<? extends Fruit> c = b;
    }
    
```
&emsp;&emsp;但是对于泛型类GenericType来说，如果其中提供了 get 和 set 类型参数变量的方法的话，set方法是不允许被调用的，会编译错误
```java
    public class GenericType<T> {
        private T date;
        public T getData(){
            return data;
        }

        public void setData(T data) {
            this.data = data;
        }
    }
    
    GenericType<? extends Fruit> c = a;
    Apple apple = new Apple();
    Fruit fruit = new Fruit();
    //这样不允许
    //c.setData(apple);
    //c.setData(fruit);
    
    //get 方法则没有问题 会返回一个Fruit类型的值
    Fruit f = c.getDate();
```
为何呢？

&emsp;&emsp;道理很简单， ```？ extends X``` 表示类型的上界，类型参数是X的子类，那么可以肯定的说，get 方法返回的是个X(不管是X或者X的子类)编译器是可以确定知道的。但是set方法只是知道传入的是个X ，至于具体X是哪个子类，不知道。
**总结：主要用于安全的访问数据，可以访问X及其子类型，并且不能写入非null的数据。**
## ？super X
表示传递给方法的参数，必须是X的超类（包括X本身）
```java
    public static void printSuper(GenericType<? super Apple> p) {
        System.out.println(p.getData());
    }

    public static void useSuper(){
        GenericType<Fruit> fruitGenericType = new GEnericType<>();
        GenericType<Apple> appleGenericType = new GEnericType<>();
        GenericType<HoneFuShi> hongfushiGenericType = new GEnericType<>();
        GenericType<Orange> orangeGenericType = new GEnericType<>();
        printSuper(fruitGenericType);
        printSuper(appleGenericType);
        printSuper(hongfushiGenericType);  //会报错
        printSuper(orangeGenericType);//会报错
    }
```
&emsp;&emsp;但是对泛型类GenericType来说，如果其中提供了get 和 set 类型参数变量的方法的话，set方法可以被调用，且能传入的参数只能是X 或者X的子类
```java
    public class GenericType<T> {
        private T date;
        public T getData(){
            return data;
        }

        public void setData(T data) {
            this.data = data;
        }
    }
    
    GenericType<? super Fruit> x = new GenericType<>();

    x.setData(new Apple);
    x.setData(new HongFuShi());
    Object z = x.getData();

    //get 方法智慧返回一个Object类型的值。
    Fruit y = c.getData();
```
&emsp;&emsp;```? super X ```表示类型的下界，类型参数是X的超类（包括X本身），那么可以肯定的说，get方法返回的一定是个X的超类，那么到底是哪个超类？不知道，但是Object 一定是它的超类，所以 get 方法返回Object。编译器是可以确定知道的。对于set方法来说，编译器不知道它需要的确切类型，但是X 和X 的子类可以安全的转型为X。

**总结：主要用于安全地写入数据，可以写入X及其子类型。**
## 无限定的通配符 ？
表示对类型没有什么限制，可以把？看成所有类型的父类，如 Pair<?>;

比如：
```
ArrayList<T> al = new ArrayList<T>();指定集合元素只能是T类型。
ArrayList<?> al = new ArrayList<?>();集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法。
```

在使用上：
```？ getFruit():```返回值只能赋给Object;
```void setFrist(?): setFirst``` 方法不能被调用，甚至不能用 Object调用；

## 虚拟机时如何实现泛型的？
&emsp;&emsp;泛型思想早在C++ 语言的模板（Template)中就开始生根发芽，在Java语言处于还没有出行泛型的版本时，只能通过Object时所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。由于Java语言里面所有的类型都继承于java.lang.Object,所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底时个什么类型的对象。在编译器间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassException的风险就会转嫁到程序运行期之中。
&emsp;&emsp;泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面的泛型无论在程序源码中、编译后的IL中（Intermediate Language,中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，```List<int>``` 与 ```List<String>```就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现成为类型膨胀，基于这种方法实现的泛型称为真实泛型。
&emsp;&emsp;Java 语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type 也称为裸类型）,并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，```ArrayList<int>```与```ArrayList<String>```就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
&emsp;&emsp;将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型。

```java
        public static String method(List<String> stringList) {
            System.out.println("List");
            return "OK";
        }

        public static Integer method(List<Integer> integerList){
            System.out.println("List");
            return 0;
        }
```

&emsp;&emsp;上面这段代码是不能被编译的，因为```List<Integer>和List<String>```编译之后都被擦除了，变成了一样的原生类型```List<E>```，擦除动作导致这两种方法的特征签名变得一模一样。

&emsp;&emsp;由于Java泛型的引入，各种场景（虚拟机解析、反射等）下的方法调用都可能对原有的基础产生影响和新的需求，如在泛型类中如何获取传入的参数化类型等。因此JCP组织对虚拟机规范做出了相应的修改，引入了诸如Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题，Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名[3],这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息。修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确地识别Signature参数。

&emsp;&emsp;另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。
